{"version":3,"file":"angular-indexed-db.min.js","sources":["angular-indexed-db.js"],"names":["__slice","slice","angular","module","provider","IDBKeyRange","allTransactions","apiDirection","appendResultsToPromise","applyNeededUpgrades","cursorDirection","cursorValueMapping","db","dbMode","dbName","dbPromise","dbVersion","deafultCursorValueMapping","defaultQueryOptions","errorMessageFor","indexedDB","readyState","upgradesByVersion","window","mozIndexedDB","webkitIndexedDB","msIndexedDB","mozIDBKeyRange","webkitIDBKeyRange","msIDBKeyRange","readonly","readwrite","pending","next","nextunique","prev","prevunique","ascending","descending","cursor","id","val","value","key","Object","defineProperty","enumerable","writable","useIndex","keyRange","direction","oldVersion","event","tx","version","hasOwnProperty","console","debug","e","target","webkitErrorMessage","error","message","errorCode","promise","results","then","this","connection","databaseName","upgradeDatabase","newVersion","callback","Math","max","apply","keys","setCursorValueMapping","newMapper","$get","$q","$rootScope","DbQ","ObjectStore","Query","Transaction","addTransaction","closeDatabase","createDatabaseConnection","keyRangeForOptions","openDatabase","openTransaction","rejectWithError","validateStoreNames","deferred","$apply","reject","dbReq","defer","open","onsuccess","result","resolve","onblocked","onerror","onupgradeneeded","transaction","name","close","storeNames","found","storeName","_i","_len","length","objectStoreNames","contains","mode","options","beginKey","endKey","bound","push","index","indexOf","splice","setupCallbacks","prototype","oncomplete","_this","onabort","objectStore","abort","q","args","arguments","call","_ref","rejectWith","req","notify","dbErrorFunction","resolveWith","store","_mapCursor","mapFunc","openCursor","_arrayOperation","data","item","isArray","when","getAllKeys","clear","upsert","put","insert","add","getAll","eachWhere","query","indexName","findWhere","each","eachBy","count","find","get","findBy","$lt","upperBound","$gt","lowerBound","$lte","$gte","$eq","only","$between","low","hi","exLow","exHi","$desc","unique","$asc","$index","openStore","callBack","openStores","objectStores","_results","openAllStores","Array","deleteDatabase","queryDirection","flush","all","databaseInfo","stores","keyPath","autoIncrement","indices","indexNames"],"mappings":"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","sourcesContent":["\n/**\n @license $indexedDBProvider\n (c) 2014 Bram Whillock (bramski)\n Forked from original work by clements Capitan (webcss)\n License: MIT\n */\n\n(function() {\n  'use strict';\n  var __slice = [].slice;\n\n  angular.module('indexedDB', []).provider('$indexedDB', function() {\n    var IDBKeyRange, allTransactions, apiDirection, appendResultsToPromise, applyNeededUpgrades, cursorDirection, cursorValueMapping, db, dbMode, dbName, dbPromise, dbVersion, deafultCursorValueMapping, defaultQueryOptions, errorMessageFor, indexedDB, readyState, upgradesByVersion;\n    indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n    IDBKeyRange = window.IDBKeyRange || window.mozIDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;\n    dbMode = {\n      readonly: \"readonly\",\n      readwrite: \"readwrite\"\n    };\n    readyState = {\n      pending: \"pending\"\n    };\n    cursorDirection = {\n      next: \"next\",\n      nextunique: \"nextunique\",\n      prev: \"prev\",\n      prevunique: \"prevunique\"\n    };\n    apiDirection = {\n      ascending: cursorDirection.next,\n      descending: cursorDirection.prev\n    };\n    cursorValueMapping = deafultCursorValueMapping = function(cursor) {\n      var id, val;\n      val = cursor.value;\n      id = cursor.key;\n      return Object.defineProperty(val, \"$key\", {\n        value: id,\n        enumerable: false,\n        writable: false\n      });\n    };\n    dbName = '';\n    dbVersion = 1;\n    db = null;\n    upgradesByVersion = {};\n    dbPromise = null;\n    allTransactions = [];\n    defaultQueryOptions = {\n      useIndex: void 0,\n      keyRange: null,\n      direction: cursorDirection.next\n    };\n    applyNeededUpgrades = function(oldVersion, event, db, tx) {\n      var version;\n      for (version in upgradesByVersion) {\n        if (!upgradesByVersion.hasOwnProperty(version) || version <= oldVersion) {\n          continue;\n        }\n        console.debug(\"$indexedDB: Running upgrade : \" + version + \" from \" + oldVersion);\n        upgradesByVersion[version](event, db, tx);\n      }\n    };\n    errorMessageFor = function(e) {\n      if (e.target.readyState === readyState.pending) {\n        return \"Error: Operation pending\";\n      } else {\n        return e.target.webkitErrorMessage || e.target.error.message || e.target.errorCode;\n      }\n    };\n    appendResultsToPromise = function(promise, results) {\n      if (results !== void 0) {\n        return promise.then(function() {\n          return results;\n        });\n      } else {\n        return promise;\n      }\n    };\n\n    /**\n    @ngdoc function\n    @name $indexedDBProvider.connection\n    @function\n    \n    @description\n    sets the name of the database to use\n    \n    @param {string} databaseName database name.\n    @returns {object} this\n     */\n    this.connection = function(databaseName) {\n      dbName = databaseName;\n      return this;\n    };\n\n    /**\n    @ngdoc function\n    @name $indexedDBProvider.upgradeDatabase\n    @function\n    \n    @description provides version number and steps to upgrade the database wrapped in a\n    callback function\n    \n    @param {number} newVersion new version number for the database.\n    @param {function} callback the callback which proceeds the upgrade\n    @returns {object} this\n     */\n    this.upgradeDatabase = function(newVersion, callback) {\n      upgradesByVersion[newVersion] = callback;\n      dbVersion = Math.max.apply(null, Object.keys(upgradesByVersion));\n      return this;\n    };\n    this.setCursorValueMapping = function(newMapper) {\n      if (newMapper == null) {\n        newMapper = deafultCursorValueMapping;\n      }\n      cursorValueMapping = newMapper;\n      return this;\n    };\n    this.$get = [\n      '$q', '$rootScope', function($q, $rootScope) {\n        var DbQ, ObjectStore, Query, Transaction, addTransaction, closeDatabase, createDatabaseConnection, keyRangeForOptions, openDatabase, openTransaction, rejectWithError, validateStoreNames;\n        rejectWithError = function(deferred) {\n          return function(error) {\n            return $rootScope.$apply(function() {\n              return deferred.reject(errorMessageFor(error));\n            });\n          };\n        };\n        createDatabaseConnection = function() {\n          var dbReq, deferred;\n          deferred = $q.defer();\n          dbReq = indexedDB.open(dbName, dbVersion || 1);\n          dbReq.onsuccess = function() {\n            db = dbReq.result;\n            $rootScope.$apply(function() {\n              deferred.resolve(db);\n            });\n          };\n          dbReq.onblocked = dbReq.onerror = rejectWithError(deferred);\n          dbReq.onupgradeneeded = function(event) {\n            var tx;\n            db = event.target.result;\n            tx = event.target.transaction;\n            console.debug(\"$indexedDB: Upgrading database '\" + db.name + \"' from version \" + event.oldVersion + \" to version \" + event.newVersion + \" ...\");\n            applyNeededUpgrades(event.oldVersion, event, db, tx);\n          };\n          return deferred.promise;\n        };\n        openDatabase = function() {\n          return dbPromise || (dbPromise = createDatabaseConnection());\n        };\n        closeDatabase = function() {\n          return openDatabase().then(function() {\n            db.close();\n            db = null;\n            return dbPromise = null;\n          });\n        };\n        validateStoreNames = function(storeNames) {\n          var found, storeName, _i, _len;\n          found = true;\n          for (_i = 0, _len = storeNames.length; _i < _len; _i++) {\n            storeName = storeNames[_i];\n            found = found & db.objectStoreNames.contains(storeName);\n          }\n          return found;\n        };\n        openTransaction = function(storeNames, mode) {\n          if (mode == null) {\n            mode = dbMode.readonly;\n          }\n          return openDatabase().then(function() {\n            if (!validateStoreNames(storeNames)) {\n              return $q.reject(\"Object stores \" + storeNames + \" do not exist.\");\n            }\n            return new Transaction(storeNames, mode);\n          });\n        };\n        keyRangeForOptions = function(options) {\n          if (options.beginKey && options.endKey) {\n            return IDBKeyRange.bound(options.beginKey, options.endKey);\n          }\n        };\n        addTransaction = function(transaction) {\n          allTransactions.push(transaction.promise);\n          return transaction.promise[\"finally\"](function() {\n            var index;\n            index = allTransactions.indexOf(transaction.promise);\n            if (index > -1) {\n              return allTransactions.splice(index, 1);\n            }\n          });\n        };\n        Transaction = (function() {\n          function Transaction(storeNames, mode) {\n            if (mode == null) {\n              mode = dbMode.readonly;\n            }\n            this.transaction = db.transaction(storeNames, mode);\n            this.defer = $q.defer();\n            this.promise = this.defer.promise;\n            this.setupCallbacks();\n          }\n\n          Transaction.prototype.setupCallbacks = function() {\n            this.transaction.oncomplete = (function(_this) {\n              return function() {\n                return $rootScope.$apply(function() {\n                  return _this.defer.resolve(\"Transaction Completed\");\n                });\n              };\n            })(this);\n            this.transaction.onabort = (function(_this) {\n              return function(error) {\n                return $rootScope.$apply(function() {\n                  return _this.defer.reject(\"Transaction Aborted\", error);\n                });\n              };\n            })(this);\n            this.transaction.onerror = (function(_this) {\n              return function(error) {\n                return $rootScope.$apply(function() {\n                  return _this.defer.reject(\"Transaction Error\", error);\n                });\n              };\n            })(this);\n            return addTransaction(this);\n          };\n\n          Transaction.prototype.objectStore = function(storeName) {\n            return this.transaction.objectStore(storeName);\n          };\n\n          Transaction.prototype.abort = function() {\n            return this.transaction.abort();\n          };\n\n          return Transaction;\n\n        })();\n        DbQ = (function() {\n          function DbQ() {\n            this.q = $q.defer();\n            this.promise = this.q.promise;\n          }\n\n          DbQ.prototype.reject = function() {\n            var args;\n            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n            return $rootScope.$apply((function(_this) {\n              return function() {\n                var _ref;\n                return (_ref = _this.q).reject.apply(_ref, args);\n              };\n            })(this));\n          };\n\n          DbQ.prototype.rejectWith = function(req) {\n            return req.onerror = req.onblocked = (function(_this) {\n              return function(e) {\n                return _this.reject(errorMessageFor(e));\n              };\n            })(this);\n          };\n\n          DbQ.prototype.resolve = function() {\n            var args;\n            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n            return $rootScope.$apply((function(_this) {\n              return function() {\n                var _ref;\n                return (_ref = _this.q).resolve.apply(_ref, args);\n              };\n            })(this));\n          };\n\n          DbQ.prototype.notify = function() {\n            var args;\n            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n            return $rootScope.$apply((function(_this) {\n              return function() {\n                var _ref;\n                return (_ref = _this.q).notify.apply(_ref, args);\n              };\n            })(this));\n          };\n\n          DbQ.prototype.dbErrorFunction = function() {\n            return (function(_this) {\n              return function(error) {\n                return $rootScope.$apply(function() {\n                  return _this.q.reject(errorMessageFor(error));\n                });\n              };\n            })(this);\n          };\n\n          DbQ.prototype.resolveWith = function(req) {\n            this.rejectWith(req);\n            return req.onsuccess = (function(_this) {\n              return function(e) {\n                return _this.resolve(e.target.result);\n              };\n            })(this);\n          };\n\n          return DbQ;\n\n        })();\n        ObjectStore = (function() {\n          function ObjectStore(storeName, transaction) {\n            this.storeName = storeName;\n            this.store = transaction.objectStore(storeName);\n            this.transaction = transaction;\n          }\n\n          ObjectStore.prototype.defer = function() {\n            return new DbQ();\n          };\n\n          ObjectStore.prototype._mapCursor = function(defer, mapFunc, req) {\n            var results;\n            if (req == null) {\n              req = this.store.openCursor();\n            }\n            results = [];\n            defer.rejectWith(req);\n            return req.onsuccess = function(e) {\n              var cursor;\n              if (cursor = e.target.result) {\n                results.push(mapFunc(cursor));\n                defer.notify(mapFunc(cursor));\n                return cursor[\"continue\"]();\n              } else {\n                return defer.resolve(results);\n              }\n            };\n          };\n\n          ObjectStore.prototype._arrayOperation = function(data, mapFunc) {\n            var defer, item, req, results, _i, _len;\n            defer = this.defer();\n            if (!angular.isArray(data)) {\n              data = [data];\n            }\n            for (_i = 0, _len = data.length; _i < _len; _i++) {\n              item = data[_i];\n              req = mapFunc(item);\n              results = [];\n              defer.rejectWith(req);\n              req.onsuccess = function(e) {\n                results.push(e.target.result);\n                defer.notify(e.target.result);\n                if (results.length >= data.length) {\n                  return defer.resolve(results);\n                }\n              };\n            }\n            if (data.length === 0) {\n              return $q.when([]);\n            }\n            return defer.promise;\n          };\n\n\n          /**\n            @ngdoc function\n            @name $indexedDBProvider.store.getAllKeys\n            @function\n          \n            @description\n            gets all the keys\n          \n            @returns {Q} A promise which will result with all the keys\n           */\n\n          ObjectStore.prototype.getAllKeys = function() {\n            var defer, req;\n            defer = this.defer();\n            if (this.store.getAllKeys) {\n              req = this.store.getAllKeys();\n              defer.resolveWith(req);\n            } else {\n              this._mapCursor(defer, function(cursor) {\n                return cursor.key;\n              });\n            }\n            return defer.promise;\n          };\n\n\n          /**\n            @ngdoc function\n            @name $indexedDBProvider.store.clear\n            @function\n          \n            @description\n            clears all objects from this store\n          \n            @returns {Q} A promise that this can be done successfully.\n           */\n\n          ObjectStore.prototype.clear = function() {\n            var defer, req;\n            defer = this.defer();\n            req = this.store.clear();\n            defer.resolveWith(req);\n            return defer.promise;\n          };\n\n\n          /**\n            @ngdoc function\n            @name $indexedDBProvider.store.delete\n            @function\n          \n            @description\n            Deletes the item at the key.  The operation is ignored if the item does not exist.\n          \n            @param {key} The key of the object to delete.\n            @returns {Q} A promise that this can be done successfully.\n           */\n\n          ObjectStore.prototype[\"delete\"] = function(key) {\n            var defer;\n            defer = this.defer();\n            defer.resolveWith(this.store[\"delete\"](key));\n            return defer.promise;\n          };\n\n\n          /**\n            @ngdoc function\n            @name $indexedDBProvider.store.upsert\n            @function\n          \n            @description\n            Updates the given item\n          \n            @param {data} Details of the item or items to update or insert\n            @returns {Q} A promise that this can be done successfully.\n           */\n\n          ObjectStore.prototype.upsert = function(data) {\n            return this._arrayOperation(data, (function(_this) {\n              return function(item) {\n                return _this.store.put(item);\n              };\n            })(this));\n          };\n\n\n          /**\n            @ngdoc function\n            @name $indexedDBProvider.store.insert\n            @function\n          \n            @description\n            Updates the given item\n          \n            @param {data} Details of the item or items to insert\n            @returns {Q} A promise that this can be done successfully.\n           */\n\n          ObjectStore.prototype.insert = function(data) {\n            return this._arrayOperation(data, (function(_this) {\n              return function(item) {\n                return _this.store.add(item);\n              };\n            })(this));\n          };\n\n\n          /**\n            @ngdoc function\n            @name $indexedDBProvider.store.getAll\n            @function\n          \n            @description\n            Fetches all items from the store\n          \n            @returns {Q} A promise which resolves with copies of all items in the store\n           */\n\n          ObjectStore.prototype.getAll = function() {\n            var defer;\n            defer = this.defer();\n            if (this.store.getAll) {\n              defer.resolveWith(this.store.getAll());\n            } else {\n              this._mapCursor(defer, cursorValueMapping);\n            }\n            return defer.promise;\n          };\n\n          ObjectStore.prototype.eachWhere = function(query) {\n            var defer, direction, indexName, keyRange, req;\n            defer = this.defer();\n            indexName = query.indexName;\n            keyRange = query.keyRange;\n            direction = query.direction;\n            req = indexName ? this.store.index(indexName).openCursor(keyRange, direction) : this.store.openCursor(keyRange, direction);\n            this._mapCursor(defer, cursorValueMapping, req);\n            return defer.promise;\n          };\n\n          ObjectStore.prototype.findWhere = function(query) {\n            return this.eachWhere(query);\n          };\n\n\n          /**\n            @ngdoc function\n            @name $indexedDBProvider.store.each\n            @function\n          \n            @description\n            Iterates through the items in the store\n          \n            @param {options.beginKey} the key to start iterating from\n            @param {options.endKey} the key to stop iterating at\n            @param {options.direction} Direction to iterate in\n            @returns {Q} A promise which notifies with each individual item and resolves with all of them.\n           */\n\n          ObjectStore.prototype.each = function(options) {\n            if (options == null) {\n              options = {};\n            }\n            return this.eachBy(void 0, options);\n          };\n\n\n          /**\n            @ngdoc function\n            @name $indexedDBProvider.store.eachBy\n            @function\n          \n            @description\n            Iterates through the items in the store using an index\n          \n            @param {indexName} name of the index to use instead of the primary\n            @param {options.beginKey} the key to start iterating from\n            @param {options.endKey} the key to stop iterating at\n            @param {options.direction} Direction to iterate in\n            @returns {Q} A promise which notifies with each individual item and resolves with all of them.\n           */\n\n          ObjectStore.prototype.eachBy = function(indexName, options) {\n            var q;\n            if (indexName == null) {\n              indexName = void 0;\n            }\n            if (options == null) {\n              options = {};\n            }\n            q = new Query();\n            q.indexName = indexName;\n            q.keyRange = keyRangeForOptions(options);\n            q.direction = options.direction || defaultQueryOptions.direction;\n            return this.eachWhere(q);\n          };\n\n\n          /**\n            @ngdoc function\n            @name $indexedDBProvider.store.count\n            @function\n          \n            @description\n            Returns a count of the items in the store\n          \n            @returns {Q} A promise which resolves with the count of all the items in the store.\n           */\n\n          ObjectStore.prototype.count = function() {\n            var defer;\n            defer = this.defer();\n            defer.resolveWith(this.store.count());\n            return defer.promise;\n          };\n\n\n          /**\n            @ngdoc function\n            @name $indexedDBProvider.store.find\n            @function\n          \n            @description\n            Fetches an item from the store\n          \n            @returns {Q} A promise which resolves with the item from the store\n           */\n\n          ObjectStore.prototype.find = function(key) {\n            var defer, req;\n            defer = this.defer();\n            req = this.store.get(key);\n            defer.rejectWith(req);\n            req.onsuccess = (function(_this) {\n              return function(e) {\n                if (e.target.result) {\n                  return defer.resolve(e.target.result);\n                } else {\n                  return defer.reject(\"\" + _this.storeName + \":\" + key + \" not found.\");\n                }\n              };\n            })(this);\n            return defer.promise;\n          };\n\n\n          /**\n            @ngdoc function\n            @name $indexedDBProvider.store.findBy\n            @function\n          \n            @description\n            Fetches an item from the store using a named index.\n          \n            @returns {Q} A promise which resolves with the item from the store.\n           */\n\n          ObjectStore.prototype.findBy = function(index, key) {\n            var defer;\n            defer = this.defer();\n            defer.resolveWith(this.store.index(index).get(key));\n            return defer.promise;\n          };\n\n          ObjectStore.prototype.query = function() {\n            return new Query();\n          };\n\n          return ObjectStore;\n\n        })();\n        Query = (function() {\n          function Query() {\n            this.indexName = void 0;\n            this.keyRange = void 0;\n            this.direction = cursorDirection.next;\n          }\n\n          Query.prototype.$lt = function(value) {\n            this.keyRange = IDBKeyRange.upperBound(value, true);\n            return this;\n          };\n\n          Query.prototype.$gt = function(value) {\n            this.keyRange = IDBKeyRange.lowerBound(value, true);\n            return this;\n          };\n\n          Query.prototype.$lte = function(value) {\n            this.keyRange = IDBKeyRange.upperBound(value);\n            return this;\n          };\n\n          Query.prototype.$gte = function(value) {\n            this.keyRange = IDBKeyRange.lowerBound(value);\n            return this;\n          };\n\n          Query.prototype.$eq = function(value) {\n            this.keyRange = IDBKeyRange.only(value);\n            return this;\n          };\n\n          Query.prototype.$between = function(low, hi, exLow, exHi) {\n            if (exLow == null) {\n              exLow = false;\n            }\n            if (exHi == null) {\n              exHi = false;\n            }\n            this.keyRange = IDBKeyRange.bound(low, hi, exLow, exHi);\n            return this;\n          };\n\n          Query.prototype.$desc = function(unique) {\n            this.direction = unique ? cursorDirection.prevunique : cursorDirection.prev;\n            return this;\n          };\n\n          Query.prototype.$asc = function(unique) {\n            this.direction = unique ? cursorDirection.nextunique : cursorDirection.next;\n            return this;\n          };\n\n          Query.prototype.$index = function(indexName) {\n            this.indexName = indexName;\n            return this;\n          };\n\n          return Query;\n\n        })();\n        return {\n\n          /**\n          @ngdoc method\n          @name $indexedDB.objectStore\n          @function\n          \n          @description an IDBObjectStore to use\n          \n          @params {string} storeName the name of the objectstore to use\n          @returns {object} ObjectStore\n           */\n          openStore: function(storeName, callBack, mode) {\n            if (mode == null) {\n              mode = dbMode.readwrite;\n            }\n            return openTransaction([storeName], mode).then(function(transaction) {\n              var results;\n              results = callBack(new ObjectStore(storeName, transaction));\n              return appendResultsToPromise(transaction.promise, results);\n            });\n          },\n          openStores: function(storeNames, callback, mode) {\n            if (mode == null) {\n              mode = dbMode.readwrite;\n            }\n            return openTransaction(storeNames, mode).then(function(transaction) {\n              var objectStores, results, storeName;\n              objectStores = (function() {\n                var _i, _len, _results;\n                _results = [];\n                for (_i = 0, _len = storeNames.length; _i < _len; _i++) {\n                  storeName = storeNames[_i];\n                  _results.push(new ObjectStore(storeName, transaction));\n                }\n                return _results;\n              })();\n              results = callback.apply(null, objectStores);\n              return appendResultsToPromise(transaction.promise, results);\n            });\n          },\n          openAllStores: function(callback, mode) {\n            if (mode == null) {\n              mode = dbMode.readwrite;\n            }\n            return openDatabase().then((function(_this) {\n              return function() {\n                var objectStores, results, storeName, storeNames, transaction;\n                storeNames = Array.prototype.slice.apply(db.objectStoreNames);\n                transaction = new Transaction(storeNames, mode);\n                objectStores = (function() {\n                  var _i, _len, _results;\n                  _results = [];\n                  for (_i = 0, _len = storeNames.length; _i < _len; _i++) {\n                    storeName = storeNames[_i];\n                    _results.push(new ObjectStore(storeName, transaction));\n                  }\n                  return _results;\n                })();\n                results = callback.apply(null, objectStores);\n                return appendResultsToPromise(transaction.promise, results);\n              };\n            })(this));\n          },\n\n          /**\n            @ngdoc method\n            @name $indexedDB.closeDatabase\n            @function\n          \n            @description Closes the database for use and completes all transactions.\n           */\n          closeDatabase: function() {\n            return closeDatabase();\n          },\n\n          /**\n            @ngdoc method\n            @name $indexedDB.deleteDatabase\n            @function\n          \n            @description Closes and then destroys the current database.  Returns a promise that resolves when this is persisted.\n           */\n          deleteDatabase: function() {\n            return closeDatabase().then(function() {\n              var defer;\n              defer = new DbQ();\n              defer.resolveWith(indexedDB.deleteDatabase(dbName));\n              return defer.promise;\n            })[\"finally\"](function() {\n              return console.debug(\"$indexedDB: \" + dbName + \" database deleted.\");\n            });\n          },\n          queryDirection: apiDirection,\n          flush: function() {\n            if (allTransactions.length > 0) {\n              return $q.all(allTransactions);\n            } else {\n              return $q.when([]);\n            }\n          },\n\n          /**\n            @ngdoc method\n            @name $indexedDB.databaseInfo\n            @function\n          \n            @description Returns information about this database.\n           */\n          databaseInfo: function() {\n            return openDatabase().then(function() {\n              var storeNames, transaction;\n              transaction = null;\n              storeNames = Array.prototype.slice.apply(db.objectStoreNames);\n              return openTransaction(storeNames, dbMode.readonly).then(function(transaction) {\n                var store, storeName, stores;\n                stores = (function() {\n                  var _i, _len, _results;\n                  _results = [];\n                  for (_i = 0, _len = storeNames.length; _i < _len; _i++) {\n                    storeName = storeNames[_i];\n                    store = transaction.objectStore(storeName);\n                    _results.push({\n                      name: storeName,\n                      keyPath: store.keyPath,\n                      autoIncrement: store.autoIncrement,\n                      indices: Array.prototype.slice.apply(store.indexNames)\n                    });\n                  }\n                  return _results;\n                })();\n                return transaction.promise.then(function() {\n                  return {\n                    name: db.name,\n                    version: db.version,\n                    objectStores: stores\n                  };\n                });\n              });\n            });\n          }\n        };\n      }\n    ];\n  });\n\n}).call(this);\n\n//# sourceMappingURL=angular-indexed-db.js.map\n"]}